{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Steps to run simulation\

\b \ul Array Synthesis
\b0 \ulnone \
1. Run combs9.m to generate the prefix tree dictionary which is stored in combs9.mat.\
1a. We generated 4 types with different grid sizes, discretization levels.\
\
2. Run case_combs3.m to traverse the tree and evaluate beam parameters for full configurations (leaf node contains config with all Nsub subarrays) which are stored in data_combs9.mat.\
\
3. Analyze the beamparameters and do placement optimization using Lagrangian_optimization.m which returns configuration (subarray centers and poses(up/down)) in <date>.mat.\
3a. This script also does local refinement in position and phase to improve cost.\
\

\b Array analysis
\b0 \
4. Run script_ZZB2.m to analyze the estimation theoretic bounds for array configurations in <date>.mat.\
4a. Figures saved in Results2 folder.\
\
Array performance\
5. Run Compressive_Estimation3.m to evaluate performance of algorithms with both compressive and full measurements.\
5a. Also evaluates the min DoA separation required for detecting 2 close targets.}